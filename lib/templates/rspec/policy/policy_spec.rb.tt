require "rails_helper"

RSpec.describe <%= class_name %>Policy do
  subject { described_class.new(user, record) }

  let(:user) { create(:user) }
  let(:record) { create(:<%= singular_table_name %>) }

  describe "scope" do
    let!(:<%= singular_table_name %>_1) { create(:<%= singular_table_name %>) }
    let!(:<%= singular_table_name %>_2) { create(:<%= singular_table_name %>) }
    let!(:<%= singular_table_name %>_3) { create(:<%= singular_table_name %>) }

    context "for super admin" do
      let(:user) { create(:user, :super_admin) }

      it "shows all <%= plural_table_name %>" do
        scope = <%= class_name %>Policy::Scope.new(user, <%= class_name %>).resolve
        expect(scope).to include(<%= singular_table_name %>_1, <%= singular_table_name %>_2, <%= singular_table_name %>_3)
      end
    end

    context "for admin" do
      let(:user) { create(:user, :admin) }

      it "shows all <%= plural_table_name %>" do
        scope = <%= class_name %>Policy::Scope.new(user, <%= class_name %>).resolve
        expect(scope).to include(<%= singular_table_name %>_1, <%= singular_table_name %>_2, <%= singular_table_name %>_3)
      end
    end

    context "for operator" do
      let(:user) { create(:user, :operator) }
<% if attributes.any? { |attr| attr.name == "user_id" } -%>
      let!(:user_<%= singular_table_name %>) { create(:<%= singular_table_name %>, user: user) }

      it "shows only own <%= plural_table_name %>" do
        scope = <%= class_name %>Policy::Scope.new(user, <%= class_name %>).resolve
        expect(scope).to include(user_<%= singular_table_name %>)
        expect(scope).not_to include(<%= singular_table_name %>_1, <%= singular_table_name %>_2, <%= singular_table_name %>_3)
      end
<% else -%>
      it "shows all <%= plural_table_name %>" do
        scope = <%= class_name %>Policy::Scope.new(user, <%= class_name %>).resolve
        expect(scope).to include(<%= singular_table_name %>_1, <%= singular_table_name %>_2, <%= singular_table_name %>_3)
      end
<% end -%>
    end
  end

  describe "index?" do
    context "for super admin" do
      let(:user) { create(:user, :super_admin) }

      it { is_expected.to permit_action(:index) }
    end

    context "for admin" do
      let(:user) { create(:user, :admin) }

      it { is_expected.to permit_action(:index) }
    end

    context "for operator" do
      let(:user) { create(:user, :operator) }

      it { is_expected.to permit_action(:index) }
    end
  end

  describe "show?" do
    context "for super admin" do
      let(:user) { create(:user, :super_admin) }

      it { is_expected.to permit_action(:show) }
    end

    context "for admin" do
      let(:user) { create(:user, :admin) }

      it { is_expected.to permit_action(:show) }
    end

    context "for operator" do
      let(:user) { create(:user, :operator) }
<% if attributes.any? { |attr| attr.name == "user_id" } -%>
      context "when <%= singular_table_name %> belongs to user" do
        let(:record) { create(:<%= singular_table_name %>, user: user) }

        it { is_expected.to permit_action(:show) }
      end

      context "when <%= singular_table_name %> does not belong to user" do
        let(:record) { create(:<%= singular_table_name %>, user: create(:user)) }

        it { is_expected.to forbid_action(:show) }
      end
<% else -%>
      it { is_expected.to permit_action(:show) }
<% end -%>
    end
  end

  describe "create?" do
    context "for super admin" do
      let(:user) { create(:user, :super_admin) }

      it { is_expected.to permit_action(:create) }
    end

    context "for admin" do
      let(:user) { create(:user, :admin) }

      it { is_expected.to permit_action(:create) }
    end

    context "for operator" do
      let(:user) { create(:user, :operator) }

      it { is_expected.to forbid_action(:create) }
    end
  end

  describe "update?" do
    context "for super admin" do
      let(:user) { create(:user, :super_admin) }

      it { is_expected.to permit_action(:update) }
    end

    context "for admin" do
      let(:user) { create(:user, :admin) }

      it { is_expected.to permit_action(:update) }
    end

    context "for operator" do
      let(:user) { create(:user, :operator) }
<% if attributes.any? { |attr| attr.name == "user_id" } -%>
      context "when <%= singular_table_name %> belongs to user" do
        let(:record) { create(:<%= singular_table_name %>, user: user) }

        it { is_expected.to permit_action(:update) }
      end

      context "when <%= singular_table_name %> does not belong to user" do
        let(:record) { create(:<%= singular_table_name %>, user: create(:user)) }

        it { is_expected.to forbid_action(:update) }
      end
<% else -%>
      it { is_expected.to forbid_action(:update) }
<% end -%>
    end
  end

  describe "destroy?" do
    context "for super admin" do
      let(:user) { create(:user, :super_admin) }

      it { is_expected.to permit_action(:destroy) }
    end

    context "for admin" do
      let(:user) { create(:user, :admin) }

      it { is_expected.to permit_action(:destroy) }
    end

    context "for operator" do
      let(:user) { create(:user, :operator) }
<% if attributes.any? { |attr| attr.name == "user_id" } -%>
      context "when <%= singular_table_name %> belongs to user" do
        let(:record) { create(:<%= singular_table_name %>, user: user) }

        it { is_expected.to permit_action(:destroy) }
      end

      context "when <%= singular_table_name %> does not belong to user" do
        let(:record) { create(:<%= singular_table_name %>, user: create(:user)) }

        it { is_expected.to forbid_action(:destroy) }
      end
<% else -%>
      it { is_expected.to forbid_action(:destroy) }
<% end -%>
    end
  end

  describe "manage?" do
    context "for super admin" do
      let(:user) { create(:user, :super_admin) }

      it { is_expected.to permit_action(:manage) }
    end

    context "for admin" do
      let(:user) { create(:user, :admin) }

      it { is_expected.to permit_action(:manage) }
    end

    context "for operator" do
      let(:user) { create(:user, :operator) }

      it { is_expected.to forbid_action(:manage) }
    end
  end

  describe "moderate?" do
    context "for super admin" do
      let(:user) { create(:user, :super_admin) }

      it { is_expected.to permit_action(:moderate) }
    end

    context "for admin" do
      let(:user) { create(:user, :admin) }

      it { is_expected.to permit_action(:moderate) }
    end

    context "for operator" do
      let(:user) { create(:user, :operator) }

      it { is_expected.to forbid_action(:moderate) }
    end
  end
end 